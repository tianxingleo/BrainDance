这是一个非常经典的**前后端协同**场景。

在你的架构中，搜索流程涉及三个角色：

1. **Flutter (前端)**：负责接收用户输入，展示结果。
2. **Supabase (数据库)**：负责存储数据、执行向量相似度计算 (RPC)。
3. **Python (AI 引擎)**：负责把“搜索词”翻译成“向量” (Embedding)。

**核心痛点**：Flutter 端不能直接生成向量（因为不能把 `DASHSCOPE_API_KEY` 暴露在手机端 App 里），所以你需要提供一个 **API 接口** 给前端。

以下是协同的最佳实践方案。

---

### 第一步：确立“接口契约” (API Contract)

在写代码之前，你先和前端同学约定好输入和输出。

**告诉前端同学：**

> “我将为你提供一个 HTTP GET 接口。你不需要管向量数据库和 AI，只要传文字给我，我返回 JSON 列表给你。”

#### 1. 请求格式

* **Method**: `GET`
* **URL**: `https://你的服务器地址/api/search` (或者本地测试 `http://127.0.0.1:8000/search`)
* **Params**:
* `q`: 搜索关键词 (必填，例如 "红色的杯子")
* `start`: 开始时间 (选填，ISO8601，例如 "2025-01-01")
* `end`: 结束时间 (选填)



#### 2. 响应格式 (JSON)

```json
{
  "code": 200,
  "data": [
    {
      "scene_id": "scene_party_001",
      "description": "一张浅棕色木质桌面上...",
      "score": 0.85,  // 相似度
      "cover_url": "https://.../preview.jpg", // 预览图(如果有)
      "model_url": "https://.../point_cloud.ply", // 模型下载链接
      "tags": ["室内", "办公"],
      "created_at": "2026-01-16T14:00:00Z"
    }
  ]
}

```

---

### 第二步：后端实现 (你的工作)

你需要把之前的 `search_demo.py` 包装成一个轻量级的 Web 服务。最快的方法是使用 **FastAPI**。

请新建文件 `server.py`：

```python
# server.py
import uvicorn
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Optional
from src.modules.knowledge_base import KnowledgeBase # 复用你现有的模块
from supabase import create_client
import os
from dotenv import load_dotenv
from openai import OpenAI

load_dotenv()

app = FastAPI()

# --- 初始化 (复用 search_demo.py 的逻辑) ---
SUP_URL = os.getenv("SUPABASE_URL")
SUP_KEY = os.getenv("SUPABASE_KEY")
AI_KEY = os.getenv("DASHSCOPE_API_KEY")

supabase = create_client(SUP_URL, SUP_KEY)
ai_client = OpenAI(api_key=AI_KEY, base_url="https://dashscope.aliyuncs.com/compatible-mode/v1")

def get_embedding(text: str):
    try:
        resp = ai_client.embeddings.create(input=[text], model="text-embedding-v2")
        return resp.data[0].embedding
    except Exception:
        return None

# --- API 接口 ---
@app.get("/search")
async def search_models(q: str, start: Optional[str] = None, end: Optional[str] = None):
    """
    前端调用的搜索接口
    """
    print(f"收到搜索请求: {q}")
    
    # 1. 转向量
    vector = get_embedding(q)
    if not vector:
        raise HTTPException(status_code=500, detail="AI Embedding 生成失败")

    # 2. 查数据库 (调用 RPC)
    try:
        rpc_params = {
            "query_embedding": vector,
            "match_threshold": 0.4, # 阈值
            "match_count": 10,      # 返回前10个
            "filter_start": start,
            "filter_end": end
        }
        response = supabase.rpc("match_model_assets", rpc_params).execute()
        results = response.data
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"数据库查询失败: {str(e)}")

    # 3. 格式化返回数据 (为前端拼接好下载链接)
    formatted_data = []
    for item in results:
        # 拼接 Supabase Storage 的公开链接 (假设 Bucket 是 public 的)
        # 如果 Bucket 是 private，这里需要用 supabase.storage.create_signed_url
        ply_path = item.get("ply_path")
        full_url = ""
        if ply_path:
             full_url = f"{SUP_URL}/storage/v1/object/public/braindance-assets/{ply_path}"

        formatted_data.append({
            "scene_id": item.get("scene_id"),
            "description": item.get("description"),
            "score": item.get("similarity"),
            "model_url": full_url,
            "created_at": item.get("created_at")
        })

    return {"code": 200, "data": formatted_data}

if __name__ == "__main__":
    # 启动服务: host="0.0.0.0" 允许局域网访问
    uvicorn.run(app, host="0.0.0.0", port=8000)

```

**运行后端：**

```bash
pip install fastapi uvicorn
python server.py

```

---

### 第三步：前端实现 (Flutter 同学的工作)

你可以把这段代码发给 Flutter 同学，告诉他核心逻辑。

**需要用到的库**：`dio` (网络请求)

```dart
// Flutter 伪代码示例

import 'package:dio/dio.dart';

class SearchService {
  // 你的电脑 IP (如果他在真机调试，不能写 localhost)
  static const String baseUrl = 'http://192.168.1.x:8000'; 
  final Dio _dio = Dio();

  Future<List<ModelAsset>> search(String query) async {
    try {
      // 1. 发起请求
      final response = await _dio.get(
        '$baseUrl/search',
        queryParameters: {
          'q': query,
          // 如果需要时间过滤，把时间传进去
          // 'start': '2025-01-01T00:00:00Z' 
        },
      );

      // 2. 解析数据
      if (response.data['code'] == 200) {
        List rawList = response.data['data'];
        return rawList.map((e) => ModelAsset.fromJson(e)).toList();
      } else {
        throw Exception('Server Error');
      }
    } catch (e) {
      print('Search failed: $e');
      return [];
    }
  }
}

// 数据模型类
class ModelAsset {
  final String sceneId;
  final String description;
  final String modelUrl;
  final double score;

  ModelAsset.fromJson(Map<String, dynamic> json)
      : sceneId = json['scene_id'],
        description = json['description'],
        modelUrl = json['model_url'],
        score = json['score'];
}

```

---

### 第四步：联调 Checklist ✅

1. **网络通不通**：
* 如果 Flutter 跑在模拟器，`localhost:8000` 是通的。
* 如果 Flutter 跑在真机，后端 URL 需要填你电脑的局域网 IP (如 `192.168.1.5:8000`)，且你的电脑要关闭防火墙。


2. **Supabase Storage 权限**：
* 确保你的 `braindance-assets` Bucket 是 **Public** 的，否则前端拿到的 `model_url` 下载不了。
* 如果必须私有，你需要修改 `server.py`，使用 `create_signed_url` 生成带签名的临时链接给前端。


3. **模型渲染**：
* 前端拿到 `.ply` 链接后，需要使用 Flutter 的 3D 渲染库（如 `flutter_gl` 或嵌入 WebView 使用 `Three.js`）来展示模型。



### 总结

这种模式下，**前端非常轻松**。他只管发 HTTP 请求，复杂的 Embedding 和 SQL 逻辑都封装在你这边的 `server.py` 里。这也是目前最主流的 "Backend for Frontend" (BFF) 模式。