这两天你进行了一场高强度的 **3DGS (3D Gaussian Splatting) 全流程工程化落地与调试**，主要是在 **Windows 下的 WSL (Ubuntu)** 环境中，为一个名为 `BrainDance` 的 AI 引擎项目优化数据处理管线。

你的核心目标是从**视频输入**到**生成高质量 3D 模型**，并解决处理速度过慢、模型质量差（“刺猬”状）以及各种环境依赖报错的问题。

以下是你这两天工作的详细技术总结：

### 一、 核心目标与策略制定
1.  **参数优化理论：**
    *   确立了 3DGS 的“甜点”参数：图片数量 **50-200 张**，训练分辨率 **1.6K - 2K**，迭代次数 **30k**。
    *   针对你的硬件情况（**弱 CPU + 强 GPU RTX 5070**），制定了策略：利用 FFmpeg 预先降采样以减轻 CPU 负担，并全力解锁 COLMAP 的 GPU 加速。

### 二、 攻克 COLMAP 的 GPU 加速（最艰难的战役）
这是耗时最长、技术难度最高的环节。你经历了从“绝望”到“编译成功”的全过程。

1.  **发现问题：**
    *   COLMAP 运行极慢（一张图匹配需 14-20秒），CPU 占用 90%，GPU 仅 40%。
    *   诊断发现 Linux 环境下的 COLMAP 是 `without CUDA` 的 CPU 阉割版。
2.  **尝试方案：**
    *   **方案 A (PyColmap):** 尝试 pip 安装 `pycolmap-cuda12`，但在 WSL 环境下未能成功调用 GPU。
    *   **方案 B (调用 Windows 版):** 尝试通过 WSL 调用宿主机 Windows 的 `colmap.exe`，虽然可行但路径转换复杂，且不利于未来迁移 Linux 服务器。
    *   **方案 C (源码编译 - 最终选择):** 决定在 Linux 下从源码编译 COLMAP。
3.  **编译踩坑与解决：**
    *   **依赖缺失：** 陆续补全了 `cmake`, `ninja`, `OpenImageIO`, `OpenCV` 等大量依赖库。
    *   **环境冲突：** Conda 环境的编译器与系统 GCC 冲突，导致找不到库。通过退出 Conda 并强制指定 `cmake` 编译器路径解决。
    *   **架构报错 (`compute_120`):** 你的 **RTX 5070 (Blackwell 架构)** 太新，旧版 CUDA Toolkit 不识别，报错不支持 `compute_120`。
        *   **神来之笔：** 通过 `CMAKE_CUDA_ARCHITECTURES=89` 强制伪装成 RTX 40 系显卡进行编译，成功骗过编译器并完美运行。
4.  **成果：** 成功编译出 `/usr/local/bin/colmap` (with CUDA)，并通过替换 Conda 环境中的旧文件/修改 PATH 优先级，让 Python 脚本成功调用了 GPU 版。

### 三、 数据清洗与预处理逻辑优化
为了提高模型质量并防止显存溢出，你对数据处理逻辑进行了多次迭代。

1.  **模糊检测算法升级：**
    *   **V1 (全局拉普拉斯):** 误删了大光圈（背景虚化）的清晰图片。
    *   **V2 (智能九宫格 + 相对阈值):** 改为将图片切分为 9 块取局部最大清晰度，并使用动态阈值（保留前 85%），完美解决了特写镜头的误删问题。
2.  **图片数量限制 (The "Ghost 201" Bug)：**
    *   试图将图片限制在 200 张，但引发了严重的 `FileNotFoundError: frame_00201.jpg`。
    *   **原因分析：** 删图逻辑发生在 COLMAP 建库之后，或者是旧的 `transforms.json` 残留导致训练器去寻找已被删除的图片。
    *   **最终方案 (沙盒隔离法):** 重构了代码逻辑。先在 `temp` 目录抽帧并清洗，选出 200 张白名单图片复制到干净的 `raw_images` 目录，再让 COLMAP 介入。物理上杜绝了脏数据。

### 四、 匹配策略与重建质量
1.  **“刺猬”模型问题：**
    *   初期使用 `vocab_tree` 导致视频帧位姿乱跳，模型全是尖刺。
    *   改为 `sequential` (顺序匹配) 后，虽然平滑了，但因为抽帧/删图导致相邻帧视差过大，COLMAP 报错 `No good initial image pair`，重建失败。
2.  **最终定案：**
    *   鉴于已经修好了 GPU 加速，计算能力不再是瓶颈。
    *   果断弃用 `sequential`，改回 **`exhaustive_matcher` (穷举匹配)**。虽然计算量大，但 GPU 能在一两分钟内搞定，且鲁棒性最强，彻底解决了断链和重建失败的问题。

### 五、 最终达成的 Pipeline 状态
你现在拥有一套 **极高鲁棒性** 且 **全自动** 的 Python 脚本 (`process_3dgs_clean_4.py`)：

1.  **初始化：** 强制清空旧数据，防止断点续传导致的 Bug。
2.  **预处理：** FFmpeg 抽帧 -> 智能模糊清洗 -> 限制数量 (沙盒模式)。
3.  **SfM 重建：**
    *   绕过 `ns-process-data` 的黑盒，**直接调用** 系统级 GPU 版 COLMAP。
    *   使用 **GPU 特征提取** + **GPU 穷举匹配** (速度快，质量高)。
    *   自动修正 COLMAP 输出目录结构（将文件归位到 `sparse/0`）。
4.  **训练准备：** 跳过 Nerfstudio 的去畸变步骤 (`--skip-image-processing`)，直接转换数据格式，避免路径混乱。
5.  **训练：** 强制使用原图分辨率 (`--downscale-factor 1`) 启动 Splatfacto 训练。

**总结：** 你从一个受限于 CPU 速度和环境报错的困境中，通过硬核编译和逻辑重构，打造了一条适配最新硬件（RTX 5070）的高效 3DGS 生产管线。